---
title: Specialized APIs
---

# {% $frontmatter.title %}

## `createQueue` and Queue Creation

### `route`: Functional Routes

In some situations, you may not know the URL you wish to route to, or may want to use Taskless for passing messages between different serverless instances. In these cases, you can specify your route as a function, returning a fully qualified URL. In these situations, you also do not need to set a job handler, as you're not planning to receive any data for this queue on this service.

```ts
import { createQueue } from "@taskless/<integration>";

// route is resolved each time enqueue() is called
createQueue("queue-name", () => "https://taskless.io/....");
```

This pattern is used in Taskless itself, to share information from our worker service (with no routable URLs) to our notification service (which sends those amazing emails when your job is failing).

### `handler`: Custom Errors and Retry-After Support

By default, Taskless operates using 2xx responses for successful job invocations and 5xx calls for failed invocations. Redirections (3xx) are followed as long as you haven't exceeded the maximum amount of time for a Taskless Job.

Taskless makes the following assumptions about your response code for simplicity:

- All `2xx` status codes are treated as a successful job invocations
- All `3xx` status codes resulting in redirection will be followed until the execution time is reached
- All `4xx` status codes are assumed to be a problem with the Taskless Client setup, and will retry similar to `500` errors
- `5xx` errors signify different types of errors when running your job. By default, a failure is assumed to be a `500` error, but the behavior can be changed by throwing a `JobError` with specific arguments

```ts
type JobErrorOptions = {
  retryAfter?: string | number;
};

export class JobError extends Error {
  statusCode: number;
  statusMessage: string;
  headers: OutgoingHttpHeaders;

  constructor(message: string, options?: JobErrorOptions) {
    super(message);
    this.statusCode = 500;
    this.statusMessage = "Internal Server Error";
    this.headers = {};
    if (typeof options?.retryAfter !== "undefined") {
      this.headers["retry-after"] = options.retryAfter;
      this.statusCode = 503;
      this.statusMessage = "Unavailable";
    }
  }
}
```

### Server Error: sending a 500 error code

A `500` error is the default Taskless error that can be generated by throwing an exception within your job handler. Alternatively, you can explicitly return a value of `taskless.error(message)`, which will record the job run as having errored.

```ts
import { createQueue, JobError } from "@taskless/client/next";

export default createQueue<Echo>(
  "my-queue-name", // üëàüèº The name of this queue, URL safe and up to 100 characters
  "/api/queues/echo", // üëàüèº The URL path this queue is reachable on
  async (job, taskless) => {
    console.log("Received a job with payload:", job);

    // send a 500
    throw new JobError("Intentionally failed");
  }
);
```

### Service Down: sending a 503 error code

If you need to delay jobs for a pre-determined amount of time, a status code of `503` can be coupled with the `Retry-After` header. When using the Taskless Client, a `JobError` will automatically become a `503` code if you provide the `retryAfter` value. Matching the [HTTP Retry-After](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header, `retryAfter` takes either a date as a UTC string, or a number of seconds that Taskless should respect before retrying the request.

```ts
import { createQueue } from "@taskless/client/next";

export default createQueue<Echo>(
  "my-queue-name", // üëàüèº The name of this queue, URL safe and up to 100 characters
  "/api/queues/echo", // üëàüèº The URL path this queue is reachable on
  async (job, taskless) => {
    console.log("Received a job with payload:", job);

    // send a retryable-after error
    throw new JobError("Down for maintenance", {
      retryAfter: 86400, // üëàüèº A UTC date or number of seconds you expect this endpoint to be down for
    });
  }
);
```

### Other Errors: `5xx` and custom error codes

If you are using Taskless in an environment where you need complete control over the error payload, you can extend the underlying `ResponseError` with your own implementation.

```ts
import { createQueue, ResponseError } from "@taskless/client/next";

type TasklessError = {
  statusCode: number;
  statusMessage: string;
  headers: OutgoingHttpHeaders;
  body: any;
};

export default createQueue<Echo>(
  "my-queue-name", // üëàüèº The name of this queue, URL safe and up to 100 characters
  "/api/queues/echo", // üëàüèº The URL path this queue is reachable on
  async (job, taskless) => {
    console.log("Received a job with payload:", job);

    // make a custom error
    const e = new ResponseError("Custom Error");
    e.statusCode = 418;
    e.statusMessage = "I'm a teapot";
    throw e;
  }
);
```

## `enqueue` And Job Creation

### Complex Job Identifiers

todo
